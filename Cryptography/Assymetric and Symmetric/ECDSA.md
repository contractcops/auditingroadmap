# Elliptic curves and ECDSA

<h2>ECDSA is Elliptic Curve Digital Signature Algorithm </h2>

ğŸ‘‰The idea is that if you are going to send a message to a friend, you could send the message + signature + public key to your friend, and the signature is computed using the private key.

ğŸ‘‰And your friend could verify the authenticity of the message with the signature and the public key

ğŸ‘‰It is possible to authenticate the data without revealing the private key.

![ECDSA](../images/EC%20and%20ECDSA/ECDSA.png)

ğŸ‘‰It is a digital signature scheme, based on the elliptic-curve cryptography(ECC).

ğŸ‘‰relies on the math of the cyclic groups of elliptic curves over finite fields and on the difficulty of the ECDLP problem (elliptic-curve discrete logarithm problem)

ğŸ‘‰The ECDSA sign / verify algorithm relies on EC point multiplication

ğŸ‘‰ECDSA keys and signatures are shorter than in RSA for the same security level

ğŸ‘‰256-bit ECDSA signature has the same security strength like 3072-bit RSA signature

Elliptic curves, used in cryptography, define:

1.Generator point G, used for scalar multiplication on the curve (multiply integer by EC point), e.g. ``G{x = 123, y = 456}``

2.Order n of the subgroup of EC points, generated by G, which defines the length of the private keys (e.g. 256 bits) e.g. ``n = 123123â€¦ ``(itâ€™s a big prime number)

<h2>Key Generation</h2>
The ECDSA key-pair consists of: <br>
Private key (integer): privateKey <br>
Public key (EC point): publicKey = privateKey * G
<br>
ğŸ‘‰The private key is generated as a random number in the range of [1â€¦n-1].

ğŸ‘‰The public key is a point on the elliptic curve, calculate by the EC point multiplication: <br>
```publicKey = privateKey * G ```, in other words: the private key, multiplied by the generator point G.

ğŸ‘‰The public key EC point {x, y} can be compressed to just one of the coordinates + 1 bit

E.g. -> for the ``secp256k1`` curve:
The private key is 256-bit integer (32 bytes)
The compressed public key is 257-bit integer (~33 bytes)

ğŸ–Šï¸ECDSA Sign <br>
ğŸ‘‰The signing algorithm takes as an input: <br>
Message - ``msg`` <br>
Private key - ``privateKey`` <br>
ğŸ‘‰And produces an output: <br>
``Signature - {r, s}`` := r and s are pair of integers

ğŸªœSteps: <br>
1.Hash the message with for example SHA-256 <br>
ğŸ‘‰``h = SHA-256(msg)`` <br>
2.Generate securely a random number k in the range [1â€¦n-1] <br>
2.1 In case of deterministic-ECDSA the value of k is HMAC derived from h + privateKey <br>
ğŸ‘‰``k`` derived from ``h + privateKey`` <br>
3.Calculate the random point ``R = k * G`` and take its x-coordinate: ğŸ‘‰ ``r = R*x`` <br>
4.Calculate the signature proof: <br>

    s = k^(-1) * (h + r * privateKey) (mod n)

4.1 The modular inverse k^(-1) (mod n) is an integer such that:

    k * k^-1 = 1 (mod n)

âœ…Return the signature ``{r, s}``

ğŸ““The calculated signature ``{r, s}`` is a pair of integers, each in the range ``[1â€¦n-1]``. It encodes the random point ``R = k * G``, along with a proof ``s``, confirming that the signer knows the message ``h`` and the private key ``privateKey``. The proof ``s`` is by idea verifiable using the corresponding ``publicKey``.

â•ECDSA signatures are 2 times longer than the signer's private key for the curve used during the signing process.

ğŸ”ECDSA Verify Signature<br>
To verify a ECDSA signature, take an input of <br>
ğŸ‘‰msg<br>
ğŸ‘‰signature ``{r, s} ``- produced by the signing algorithm<br>
ğŸ‘‰``public key`` - corresponding to the signerâ€™s ```private key```<br>
The output is: ``boolean valid || invalid signature``

ğŸªœSteps:<br>
ğŸ‘‰Calculate the message hash, with the same hashing function used during signing<br>
ğŸ‘‰Calculate the modular inverse of the signature proof:

    s1 = s^(-1) (mod n)

ğŸ‘‰Recover the random point used during the signing:<br>

    Râ€™ = (h * s1) * G + (r * s1) * publicKey

ğŸ‘‰Take from ``Râ€™`` itâ€™s ``x``-coordinate:

    râ€™ = Râ€™ * x

<br>
ğŸ‘‰Calculate the signature validation result by comparing whether

    râ€™ == r

<br>

â—The general idea of the signature verification is to recover the point Râ€™ using the public key and check whether it is same point R, generated randomly during the signing process.

Cheatsheet<br>
1ï¸.The signing encodes random ``point R`` (represented by its ``x``-coordinate only) through elliptic curve transformations using the ``private key`` and the ``message``â€™s ``hash`` into a ``number s``, which is the proof that the message signer knows the ``private key``. The signature ``{r, s}`` cannot reveal the private key due to the difficulty of the ``ECDLP problem``

2ï¸.The signature verification decodes the proof ``number s`` from the signature back to its original ``point R``, using the ``public key`` and the ``messageâ€™s hash`` and compares the ``x``-coordinate of the recovered ``R`` with the ``r`` value from the signature
